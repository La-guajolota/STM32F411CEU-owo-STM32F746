/*
 * ACS712.c
 *
 *  Created on: Apr 7, 2024
 *      Author: adria
 */

#include "ACS712.h"

/*
 * Defines del periferico en uso
 */
extern ADC_HandleTypeDef hadc3;
extern TIM_HandleTypeDef htim14;

#define micros &htim14//uS
#define millis
#define adc &hadc3

/*
 * Defines para los calculos
 */

//FORM FACTOR
#define ACS712_FF_SINUS           (1.0/sqrt(2))
#define ACS712_FF_SQUARE          (1.0)
#define ACS712_FF_TRIANGLE        (1.0/sqrt(3))
#define ACS712_FF_SAWTOOTH        (1.0/sqrt(3))

#define ACS712_DEFAULT_FREQ       60 //hz
#define ACS712_DEFAULT_NOISE      21 //hz

#define sensibilidad 1
#define mV_amps 66.0

#define midpoimt_0v 1.65 //volts

#define _microsAdjust 0.9986

/*
 * Equivalente a mcros()
 * Arduino
 *
 * __HAL_TIM_GET_COUNTER(&htim14)
 */

//  TYPE   mV per Ampere
//  5A        185.0
//  20A       100.0
//  30A        66.0 --El que tenemos
/*
	Sensor	mVperA	LSB 10bit	LSB 12bit	LSB 16bit
	5A		185		26.4 mA		6.6 mA		0.41 mA
	20A		100		48.9 mA		12.2 mA		0.76 mA
	30A		66		74.1 mA		18.5 mA		1.16 mA
*/

//  FREQUENCY DETECTION
//  uses oversampling and averaging to minimize variation
//  blocks for substantial amount of time, depending on minimalFrequency
void ACS712_Frequency(ACS712* modulo,float minimalFrequency)
{
  int maximum = 0;
  int minimum = 0;
  maximum = minimum = HAL_ADC_GetValue(adc);

  //  determine maxima
  uint32_t timeOut = round(1000000.0 / minimalFrequency);
  __HAL_TIM_SET_COUNTER(micros,0);
  while (__HAL_TIM_GET_COUNTER(micros)< timeOut)
  {
    int value = HAL_ADC_GetValue(adc);
    if (value > maximum) maximum = value;
    if (value < minimum) minimum = value;
  }

  //  calculate quarter points
  //  using quarter points is less noise prone than using one single midpoint
  int Q1 = (3 * minimum + maximum ) / 4;
  int Q3 = (minimum + 3 * maximum ) / 4;

  //  10x passing Quantile points
  //  wait for the right moment to start
  //  to prevent endless loop a timeout is checked.
  timeOut *= 10;
  __HAL_TIM_SET_COUNTER(micros,0);
  //  casting to int to keep compiler happy.
  while ((HAL_ADC_GetValue(adc) >  Q1) && (__HAL_TIM_GET_COUNTER(micros) < timeOut));
  while ((HAL_ADC_GetValue(adc) <= Q3) && (__HAL_TIM_GET_COUNTER(micros) < timeOut));
  __HAL_TIM_SET_COUNTER(micros,0);
  for (int i = 0; i < 10; i++)
  {
    while ((HAL_ADC_GetValue(adc) >  Q1) && (__HAL_TIM_GET_COUNTER(micros) < timeOut));
    while ((HAL_ADC_GetValue(adc) <= Q3) && (__HAL_TIM_GET_COUNTER(micros) < timeOut));
  }
  uint32_t stop = __HAL_TIM_GET_COUNTER(micros);

  //  calculate frequency
  float wavelength = stop;
  float frequency = 1e7 / wavelength;
  if (_microsAdjust != 1.0) frequency *= _microsAdjust;

  //ALMACENAMOS LOS VALORES CAPTURADOS
  // 	Sensor	mVperA	LSB 12bit
  //	30A		66		18.5 mA
  //
  //	En el contexto de 0v-3.3v
  //			44mVperA
  modulo->frequency = frequency;
}

void ACS712_RMS(ACS712* modulo){
	float voltajeSensor;
	float corriente=0;
	long tiempo = millis();
	float Imax=0;
	float Imin=0;

	while(millis()-tiempo<500) //realizamos mediciones durante 0.5 segundos
	  {
		voltajeSensor = analogRead(A0) * (3.3 / 4095.0); //lectura del sensor

		/* para disminuir un poco el ruido aplicamos un filtro pasa bajos, que es similar a realizar un promedio de 10 muestras*/
		corriente=0.9*corriente+0.1*((voltajeSensor-midpoimt_0v)/mV_amps); //EcuaciÃ³n para obtener la corriente

		if(corriente>Imax)Imax=corriente;
		if(corriente<Imin)Imin=corriente;
	  }

	return(((Imax-Imin)/2)-offset);
}

void ACS712_sense(ACS712* modulo){

	//FRECUENCIA
	ACS712_Frequency(modulo,0.1);

	//RMS
	ACS712_RMS(modulo);
}
